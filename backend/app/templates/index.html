<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Options Scalping Portal</title>
    <link rel="stylesheet" href="{{ url_for('static', path='style.css') }}">
</head>
<body>
    <header>
        <h1>Options Scalping Portal</h1>
        <div id="controls">
            <button id="strategy-toggle">Start Strategy</button>
            <button id="kill-switch">EMERGENCY STOP</button>
        </div>
    </header>

    <main>
        <section id="overview">
            <div>
                <h2>Account Overview</h2>
                <div id="account-details">
                    <p>Balance: <span id="balance">--</span></p>
                    <p>Margin: <span id="margin">--</span></p>
                </div>
            </div>
            <div>
                <h2>Daily Stats</h2>
                <div id="daily-stats" class="stats-grid">
                    <p>Realized P&L: <span id="realized-pnl">--</span></p>
                    <p>Total Trades: <span id="total-trades">--</span></p>
                    <p>Win Rate: <span id="win-rate">--</span></p>
                    <p>Avg. Win: <span id="avg-win">--</span></p>
                    <p>Avg. Loss: <span id="avg-loss">--</span></p>
                    <p>Trading Status: <span id="trading-status" class="negative">STOPPED</span></p>
                    <p>Data Feed: <span id="data-feed-status">--</span></p>
                </div>
            </div>
        </section>

        <section id="strategy-params">
            <h2>Strategy Parameters</h2>
            <form id="params-form">
                <div class="form-grid">
                    <div>
                        <label for="param-ema-short">EMA Short</label>
                        <input type="number" id="param-ema-short" name="ema_short">
                    </div>
                    <div>
                        <label for="param-ema-long">EMA Long</label>
                        <input type="number" id="param-ema-long" name="ema_long">
                    </div>
                    <div>
                        <label for="param-atr-period">ATR Period</label>
                        <input type="number" id="param-atr-period" name="atr_period">
                    </div>
                    <div>
                        <label for="param-st-period">SuperTrend Period</label>
                        <input type="number" id="param-st-period" name="supertrend_period">
                    </div>
                    <div>
                        <label for="param-st-multiplier">SuperTrend Multiplier</label>
                        <input type="number" step="0.1" id="param-st-multiplier" name="supertrend_multiplier">
                    </div>
                </div>
                <div class="form-actions">
                    <button type="submit">Save Parameters</button>
                    <span id="params-status"></span>
                </div>
            </form>
        </section>

        <section id="chart-section">
            <h2>Market Chart</h2>
            <div id="trading-chart"></div>
        </section>

        <section id="pnl-chart-section">
            <h2>Daily P&L Chart</h2>
            <div id="pnl-chart"></div>
        </section>

        <section id="positions-and-orders">
            <div id="positions">
                <h2>Open Positions</h2>
                <table>
                    <thead>
                        <tr><th>Symbol</th><th>Side</th><th>Qty</th><th>Entry Price</th><th>Live Price</th><th>P&L</th></tr>
                    </thead>
                    <tbody id="positions-table-body">
                        <!-- JS will populate this -->
                    </tbody>
                </table>
            </div>
            <div id="trades">
                <h2>Historical Trades</h2>
                <table>
                    <thead>
                        <tr><th>Symbol</th><th>Side</th><th>Qty</th><th>Entry</th><th>Exit</th><th>P&L</th><th>Time</th></tr>
                    </thead>
                    <tbody id="trades-table-body">
                        <!-- JS will populate this -->
                    </tbody>
                </table>
            </div>
        </section>
    </main>

    <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // --- Element References ---
            const strategyToggleBtn = document.getElementById('strategy-toggle');
            const killSwitchBtn = document.getElementById('kill-switch');
            const paramsForm = document.getElementById('params-form');
            const paramsStatusEl = document.getElementById('params-status');

            // Dashboard Elements
            const balanceEl = document.getElementById('balance');
            const marginEl = document.getElementById('margin');
            const realizedPnlEl = document.getElementById('realized-pnl');
            const totalTradesEl = document.getElementById('total-trades');
            const winRateEl = document.getElementById('win-rate');
            const avgWinEl = document.getElementById('avg-win');
            const avgLossEl = document.getElementById('avg-loss');
            const tradingStatusEl = document.getElementById('trading-status');
            const dataFeedStatusEl = document.getElementById('data-feed-status');
            const positionsTableBody = document.getElementById('positions-table-body');
            const tradesTableBody = document.getElementById('trades-table-body');

            // --- State Management ---
            let isStrategyRunning = false;

            // --- Lightweight Charts Setup ---
            const pnlChartContainer = document.getElementById('pnl-chart');
            const pnlChart = LightweightCharts.createChart(pnlChartContainer, {
                width: pnlChartContainer.clientWidth, height: 250,
                layout: { backgroundColor: '#ffffff', textColor: '#333' },
                grid: { vertLines: { color: '#f0f0f0' }, horzLines: { color: '#f0f0f0' } },
                timeScale: { timeVisible: true, secondsVisible: false }
            });
            const pnlSeries = pnlChart.addAreaSeries({
                topColor: 'rgba(46, 204, 113, 0.56)', bottomColor: 'rgba(46, 204, 113, 0.04)',
                lineColor: 'rgba(46, 204, 113, 1)', lineWidth: 2
            });

            // --- UI Update Functions ---
            function updateStats(stats) {
                if (!stats) return;

                balanceEl.textContent = `₹${stats.balance?.toFixed(2) || '0.00'}`;
                marginEl.textContent = `₹${stats.margin?.toFixed(2) || '0.00'}`;
                realizedPnlEl.textContent = `₹${stats.realized_pnl?.toFixed(2) || '0.00'}`;
                realizedPnlEl.className = (stats.realized_pnl || 0) >= 0 ? 'positive' : 'negative';

                totalTradesEl.textContent = stats.total_trades || '0';
                winRateEl.textContent = `${stats.win_rate?.toFixed(1) || '0.0'}%`;
                avgWinEl.textContent = `₹${stats.avg_win?.toFixed(2) || '0.00'}`;
                avgLossEl.textContent = `₹${stats.avg_loss?.toFixed(2) || '0.00'}`;

                isStrategyRunning = stats.is_strategy_running;
                tradingStatusEl.textContent = isStrategyRunning ? 'RUNNING' : 'STOPPED';
                tradingStatusEl.className = isStrategyRunning ? 'positive' : 'negative';
                strategyToggleBtn.textContent = isStrategyRunning ? 'Stop Strategy' : 'Start Options Scalping';
                strategyToggleBtn.disabled = false;

                dataFeedStatusEl.textContent = stats.data_feed_connected ? 'CONNECTED' : 'DISCONNECTED';
                dataFeedStatusEl.className = stats.data_feed_connected ? 'positive' : 'negative';
            }

            function updatePositions(positions) {
                positionsTableBody.innerHTML = '';
                if (positions && positions.length > 0) {
                    positions.forEach(pos => {
                        const row = document.createElement('tr');
                        const pnlClass = pos.pnl >= 0 ? 'positive' : 'negative';
                        row.innerHTML = `
                            <td>${pos.symbol}</td>
                            <td class="${pos.side.toLowerCase()}">${pos.side}</td>
                            <td>${pos.qty}</td>
                            <td>${Number(pos.entry_price).toFixed(2)}</td>
                            <td>${Number(pos.live_price).toFixed(2)}</td>
                            <td class="${pnlClass}">${pos.pnl.toFixed(2)}</td>
                        `;
                        positionsTableBody.appendChild(row);
                    });
                } else {
                    positionsTableBody.innerHTML = '<tr><td colspan="6">No open positions.</td></tr>';
                }
            }

            function updateTrades(trades) {
                tradesTableBody.innerHTML = '';
                if (trades && trades.length > 0) {
                    trades.forEach(trade => {
                        const row = document.createElement('tr');
                        const pnlClass = trade.pnl >= 0 ? 'positive' : 'negative';
                        const entryTime = new Date(trade.entry_time).toLocaleTimeString();
                        row.innerHTML = `
                            <td>${trade.symbol}</td>
                            <td class="${trade.side.toLowerCase()}">${trade.side}</td>
                            <td>${trade.qty}</td>
                            <td>₹${Number(trade.entry_price).toFixed(2)}</td>
                            <td>₹${Number(trade.exit_price).toFixed(2)}</td>
                            <td class="${pnlClass}">₹${trade.pnl.toFixed(2)}</td>
                            <td>${entryTime}</td>
                        `;
                        tradesTableBody.appendChild(row);
                    });
                } else {
                    tradesTableBody.innerHTML = '<tr><td colspan="7">No trades yet.</td></tr>';
                }
            }

            // --- API Fetch Functions ---
            async function fetchInitialData() {
                try {
                    const [statsRes, positionsRes, tradesRes, paramsRes] = await Promise.all([
                        fetch('/api/stats'),
                        fetch('/api/positions'),
                        fetch('/api/trades'),
                        fetch('/api/strategy/parameters')
                    ]);

                    if (!statsRes.ok || !positionsRes.ok || !tradesRes.ok || !paramsRes.ok) {
                        throw new Error('Failed to fetch initial data');
                    }

                    const stats = await statsRes.json();
                    const positions = await positionsRes.json();
                    const trades = await tradesRes.json();
                    const params = await paramsRes.json();

                    updateStats(stats);
                    updatePositions(positions);
                    updateTrades(trades);

                    // Populate strategy params form
                    document.getElementById('param-ema-short').value = params.ema_short || 9;
                    document.getElementById('param-ema-long').value = params.ema_long || 21;
                    document.getElementById('param-atr-period').value = params.atr_period || 14;
                    document.getElementById('param-st-period').value = params.supertrend_period || 10;
                    document.getElementById('param-st-multiplier').value = params.supertrend_multiplier || 3.0;

                } catch (err) {
                    console.error("Failed to fetch initial data:", err);
                    // You might want to display an error message to the user here
                }
            }

            // --- WebSocket Connection ---
            function connectWebSocket() {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const ws = new WebSocket(`${protocol}//${window.location.host}/api/ws/data`);

                ws.onopen = () => {
                    console.log("WebSocket connection established.");
                    dataFeedStatusEl.textContent = 'CONNECTED';
                    dataFeedStatusEl.className = 'positive';
                };

                ws.onmessage = (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        switch (message.type) {
                            case 'ping':
                                ws.send(JSON.stringify({type: 'pong'}));
                                break;
                            case 'stats_update':
                                // This is a custom event from the backend for stats
                                updateStats(message.data);
                                break;
                            case 'order_update':
                                // An order was filled/changed, refresh positions and trades
                                fetch('/api/positions').then(res => res.json()).then(updatePositions);
                                fetch('/api/trades').then(res => res.json()).then(updateTrades);
                                break;
                            case 'full_update':
                                // A comprehensive update from the backend
                                updateStats(message.data.stats);
                                updatePositions(message.data.positions);
                                updateTrades(message.data.trades);
                                break;
                            case 'market_data':
                                // Future: Update live prices without full re-fetch
                                break;
                        }
                    } catch (err) {
                        console.error('WebSocket message parse error:', err);
                    }
                };

                ws.onerror = (err) => {
                    console.error('WebSocket Error:', err);
                    dataFeedStatusEl.textContent = 'ERROR';
                    dataFeedStatusEl.className = 'negative';
                };

                ws.onclose = () => {
                    console.log("WebSocket connection closed. Attempting to reconnect in 5 seconds...");
                    dataFeedStatusEl.textContent = 'DISCONNECTED';
                    dataFeedStatusEl.className = 'negative';
                    setTimeout(connectWebSocket, 5000);
                };
            }

            // --- Event Listeners ---
            strategyToggleBtn.addEventListener('click', async () => {
                const action = isStrategyRunning ? 'stop' : 'start';
                strategyToggleBtn.disabled = true;
                strategyToggleBtn.textContent = 'Processing...';
                try {
                    const response = await fetch('/api/strategy/control', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ action })
                    });
                    if (!response.ok) {
                         const err = await response.json();
                         throw new Error(err.detail || 'Failed to control strategy');
                    }
                    // The UI will be updated via a WebSocket 'stats_update' message.
                } catch (err) {
                    console.error('Strategy control error:', err);
                    alert(`Error: ${err.message}`);
                    // Re-enable button on error
                    strategyToggleBtn.disabled = false;
                }
            });

            killSwitchBtn.addEventListener('click', async () => {
                if (confirm('EMERGENCY STOP: This will halt all trading. Are you sure?')) {
                    try {
                        const response = await fetch('/api/strategy/control', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ action: 'kill' })
                        });
                        if (!response.ok) {
                            const err = await response.json();
                            throw new Error(err.detail || 'Failed to activate kill switch');
                        }
                        const result = await response.json();
                        alert(result.status || 'Kill switch activated.');
                        // UI will update via WebSocket. Disable buttons immediately for responsiveness.
                        strategyToggleBtn.disabled = true;
                        killSwitchBtn.disabled = true;
                    } catch (err) {
                        console.error('Kill switch error:', err);
                        alert(`Error: ${err.message}`);
                    }
                }
            });

            paramsForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                paramsStatusEl.textContent = 'Saving...';
                paramsStatusEl.className = '';

                const formData = new FormData(paramsForm);
                const params = Object.fromEntries(formData.entries());

                // Convert to correct types
                Object.keys(params).forEach(key => {
                    if (key.includes('multiplier')) {
                        params[key] = parseFloat(params[key]);
                    } else {
                        params[key] = parseInt(params[key]);
                    }
                });

                try {
                    const response = await fetch('/api/strategy/parameters', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(params)
                    });
                    const result = await response.json();
                    if (!response.ok) throw new Error(result.detail || 'Save failed');

                    paramsStatusEl.textContent = 'Parameters saved!';
                    paramsStatusEl.className = 'positive';
                } catch (err) {
                    console.error('Failed to save parameters:', err);
                    paramsStatusEl.textContent = `Error: ${err.message}`;
                    paramsStatusEl.className = 'negative';
                } finally {
                    setTimeout(() => { paramsStatusEl.textContent = ''; }, 3000);
                }
            });

            // --- Initialization ---
            fetchInitialData();
            connectWebSocket();
        });
    </script>
</body>
</html>
